//! > gas_coupon_buy libfunc

//! > test_runner_name
SmallE2ETestRunner

//! > cairo_code
fn foo() -> Option<gas::GasCoupon> nopanic {
    gas::gas_coupon_buy(100)
}

//! > casm
[ap + 0] = 100, ap++;
[fp + -3] = [ap + 1] + [ap + -1], ap++;
%{ memory[ap + -1] = memory[ap + -2] <= memory[fp + -3] %}
jmp rel 7 if [ap + -1] != 0, ap++;
[ap + 0] = [ap + -1] + 340282366920938463463374607431768211456, ap++;
[ap + -1] = [[fp + -4] + 0];
jmp rel 13;
[ap + -1] = [[fp + -4] + 0];
ap += 1;
[ap + 0] = [fp + -4] + 1, ap++;
[ap + 0] = [ap + -3] + 90, ap++;
[ap + 0] = 0, ap++;
[ap + 0] = [ap + -7], ap++;
ret;
[ap + 0] = [fp + -4] + 1, ap++;
[ap + 0] = [fp + -3], ap++;
[ap + 0] = 1, ap++;
[ap + 0] = 0, ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 1070})

//! > sierra_code
type u128 = u128 [storable: true, drop: true, dup: true, zero_sized: false];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type GasCoupon = GasCoupon [storable: true, drop: true, dup: false, zero_sized: false];
type core::option::Option::<core::gas::GasCoupon> = Enum<ut@core::option::Option::<core::gas::GasCoupon>, GasCoupon, Unit> [storable: true, drop: true, dup: false, zero_sized: false];
type GasBuiltin = GasBuiltin [storable: true, drop: false, dup: false, zero_sized: false];
type RangeCheck = RangeCheck [storable: true, drop: false, dup: false, zero_sized: false];
type Const<u128, 100> = Const<u128, 100> [storable: false, drop: false, dup: false, zero_sized: false];

libfunc const_as_immediate<Const<u128, 100>> = const_as_immediate<Const<u128, 100>>;
libfunc store_temp<u128> = store_temp<u128>;
libfunc gas_coupon_buy = gas_coupon_buy;
libfunc branch_align = branch_align;
libfunc redeposit_gas = redeposit_gas;
libfunc enum_init<core::option::Option::<core::gas::GasCoupon>, 0> = enum_init<core::option::Option::<core::gas::GasCoupon>, 0>;
libfunc store_temp<RangeCheck> = store_temp<RangeCheck>;
libfunc store_temp<GasBuiltin> = store_temp<GasBuiltin>;
libfunc store_temp<core::option::Option::<core::gas::GasCoupon>> = store_temp<core::option::Option::<core::gas::GasCoupon>>;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc enum_init<core::option::Option::<core::gas::GasCoupon>, 1> = enum_init<core::option::Option::<core::gas::GasCoupon>, 1>;

F0:
const_as_immediate<Const<u128, 100>>() -> ([2]);
store_temp<u128>([2]) -> ([2]);
gas_coupon_buy([0], [1], [2]) { fallthrough([3], [4], [5]) F0_B0([6], [7]) };
branch_align() -> ();
redeposit_gas([4]) -> ([8]);
enum_init<core::option::Option::<core::gas::GasCoupon>, 0>([5]) -> ([9]);
store_temp<RangeCheck>([3]) -> ([3]);
store_temp<GasBuiltin>([8]) -> ([8]);
store_temp<core::option::Option::<core::gas::GasCoupon>>([9]) -> ([9]);
return([3], [8], [9]);
F0_B0:
branch_align() -> ();
redeposit_gas([7]) -> ([10]);
struct_construct<Unit>() -> ([11]);
enum_init<core::option::Option::<core::gas::GasCoupon>, 1>([11]) -> ([12]);
store_temp<RangeCheck>([6]) -> ([6]);
store_temp<GasBuiltin>([10]) -> ([10]);
store_temp<core::option::Option::<core::gas::GasCoupon>>([12]) -> ([12]);
return([6], [10], [12]);

test::foo@F0([0]: RangeCheck, [1]: GasBuiltin) -> (RangeCheck, GasBuiltin, core::option::Option::<core::gas::GasCoupon>);

//! > ==========================================================================

//! > redeposit_gas_coupon libfunc

//! > test_runner_name
SmallE2ETestRunner

//! > cairo_code
fn foo(coupon: gas::GasCoupon) {
    gas::redeposit_gas_coupon(coupon)
}

//! > casm
[ap + 0] = [fp + -4] + [fp + -3], ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 100})

//! > sierra_code
type GasBuiltin = GasBuiltin [storable: true, drop: false, dup: false, zero_sized: false];
type GasCoupon = GasCoupon [storable: true, drop: true, dup: false, zero_sized: false];

libfunc redeposit_gas_coupon = redeposit_gas_coupon;
libfunc store_temp<GasBuiltin> = store_temp<GasBuiltin>;

F0:
redeposit_gas_coupon([0], [1]) -> ([2]);
store_temp<GasBuiltin>([2]) -> ([2]);
return([2]);

test::foo@F0([0]: GasBuiltin, [1]: GasCoupon) -> (GasBuiltin);

//! > ==========================================================================

//! > gas coupons

//! > test_runner_name
SmallE2ETestRunner

//! > cairo_code
fn foo(mut calls: Span<starknet::account::Call>) -> bool nopanic {
    while let Some(call) = calls.pop_front() {
        if let None(()) = gas::withdraw_gas() {
            // Stop on out-of-gas.
            return false;
        }
        let res = starknet::syscalls::call_contract_syscall(
            *call.to, *call.selector, *call.calldata,
        );
        if let Err(_err) = res {
            // Stop on error.
            return false;
        }
    }
    true
}

fn bar(calls: Span<starknet::account::Call>) -> bool nopanic {
    if let Some(coupon) = gas::gas_coupon_buy(1000000) {
        let res = foo(calls);
        gas::redeposit_gas_coupon(coupon);
        res
    } else {
        false
    }
}

//! > casm
[ap + 0] = [fp + -7], ap++;
[ap + 0] = [fp + -6], ap++;
[ap + 0] = [fp + -5], ap++;
[ap + 0] = [fp + -4], ap++;
[ap + 0] = [fp + -3], ap++;
call rel 59;
jmp rel 8 if [ap + -2] != 0;
[ap + 0] = [ap + -7], ap++;
[ap + 0] = [ap + -7], ap++;
[ap + 0] = [ap + -7], ap++;
[ap + 0] = 1, ap++;
ret;
[ap + 0] = [ap + -7], ap++;
[ap + 0] = [ap + -7], ap++;
[ap + 0] = [ap + -7], ap++;
[ap + 0] = [ap + -4], ap++;
ret;
ap += 1;
[fp + 0] = 1000000;
[fp + -6] = [ap + 1] + [fp + 0], ap++;
%{ memory[ap + -1] = memory[fp + 0] <= memory[fp + -6] %}
jmp rel 7 if [ap + -1] != 0, ap++;
[ap + 0] = [ap + -1] + 340282366920938463463374607431768211456, ap++;
[ap + -1] = [[fp + -7] + 0];
jmp rel 26;
[ap + -1] = [[fp + -7] + 0];
[ap + 0] = [fp + -7] + 1, ap++;
[ap + 0] = [ap + -2], ap++;
[ap + 0] = [fp + -5], ap++;
[ap + 0] = [fp + -4], ap++;
[ap + 0] = [fp + -3], ap++;
call rel 25;
jmp rel 7 if [ap + -2] != 0;
[ap + 0] = [ap + -6], ap++;
[ap + 0] = 1, ap++;
jmp rel 5;
[ap + 0] = [ap + -6] + 100, ap++;
[ap + 0] = [ap + -2], ap++;
[ap + 0] = [ap + -9], ap++;
[ap + 0] = [ap + -3] + [fp + 0], ap++;
[ap + 0] = [ap + -9], ap++;
[ap + 0] = [ap + -4], ap++;
ret;
[ap + 0] = [fp + -7] + 1, ap++;
[ap + 0] = [fp + -6] + 2800, ap++;
[ap + 0] = [fp + -5], ap++;
[ap + 0] = 0, ap++;
ret;
[fp + -3] = [ap + 0] + [fp + -4], ap++;
jmp rel 4 if [ap + -1] != 0;
jmp rel 62;
[ap + 0] = [[fp + -4] + 0], ap++;
[ap + 0] = [[fp + -4] + 1], ap++;
[ap + 0] = [[fp + -4] + 2], ap++;
[ap + 0] = [[fp + -4] + 3], ap++;
%{ memory[ap + 0] = 12670 <= memory[fp + -6] %}
jmp rel 7 if [ap + 0] != 0, ap++;
[ap + 0] = [fp + -6] + 340282366920938463463374607431768198786, ap++;
[ap + -1] = [[fp + -7] + 0];
jmp rel 37;
[fp + -6] = [ap + 0] + 12670, ap++;
[ap + -1] = [[fp + -7] + 0];
[ap + 0] = 20853273475220472486191784820, ap++;
[ap + -1] = [[fp + -5] + 0];
[ap + -2] = [[fp + -5] + 1];
[ap + -7] = [[fp + -5] + 2];
[ap + -6] = [[fp + -5] + 3];
[ap + -5] = [[fp + -5] + 4];
[ap + -4] = [[fp + -5] + 5];
%{ syscall_handler.syscall(syscall_ptr=memory[fp + -5]) %}
[ap + 0] = [[fp + -5] + 7], ap++;
jmp rel 14 if [ap + -1] != 0;
[ap + 0] = [[fp + -5] + 6], ap++;
[ap + 0] = [fp + -7] + 1, ap++;
[ap + 0] = [ap + -2], ap++;
[ap + 0] = [fp + -5] + 10, ap++;
[ap + 0] = [fp + -4] + 4, ap++;
[ap + 0] = [fp + -3], ap++;
call rel -39;
ret;
[ap + 0] = [[fp + -5] + 6], ap++;
[ap + 0] = [fp + -7] + 1, ap++;
[ap + 0] = [ap + -2] + 1800, ap++;
[ap + 0] = [fp + -5] + 10, ap++;
jmp rel 8;
ap += 3;
[ap + 0] = [fp + -7] + 1, ap++;
[ap + 0] = [fp + -6], ap++;
[ap + 0] = [fp + -5], ap++;
[ap + 0] = [fp + -4] + 4, ap++;
[ap + 0] = [fp + -3], ap++;
[ap + 0] = 1, ap++;
[ap + 0] = 0, ap++;
ret;
[ap + 0] = [fp + -7], ap++;
[ap + 0] = [fp + -6] + 900, ap++;
[ap + 0] = [fp + -5], ap++;
[ap + 0] = [fp + -4], ap++;
[ap + 0] = [fp + -3], ap++;
[ap + 0] = 0, ap++;
[ap + 0] = 0, ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 3100})
test::bar: OrderedHashMap({Const: 3970})
test::foo[67-464]: OrderedHashMap({Const: 1900})

//! > sierra_code
type RangeCheck = RangeCheck [storable: true, drop: false, dup: false, zero_sized: false];
type Array<felt252> = Array<felt252> [storable: true, drop: true, dup: false, zero_sized: false];
type Snapshot<Array<felt252>> = Snapshot<Array<felt252>> [storable: true, drop: true, dup: true, zero_sized: false];
type core::array::Span::<core::felt252> = Struct<ut@core::array::Span::<core::felt252>, Snapshot<Array<felt252>>> [storable: true, drop: true, dup: true, zero_sized: false];
type felt252 = felt252 [storable: true, drop: true, dup: true, zero_sized: false];
type ContractAddress = ContractAddress [storable: true, drop: true, dup: true, zero_sized: false];
type core::starknet::account::Call = Struct<ut@core::starknet::account::Call, ContractAddress, felt252, core::array::Span::<core::felt252>> [storable: true, drop: true, dup: true, zero_sized: false];
type Box<core::starknet::account::Call> = Box<core::starknet::account::Call> [storable: true, drop: true, dup: true, zero_sized: false];
type Array<core::starknet::account::Call> = Array<core::starknet::account::Call> [storable: true, drop: true, dup: false, zero_sized: false];
type Snapshot<Array<core::starknet::account::Call>> = Snapshot<Array<core::starknet::account::Call>> [storable: true, drop: true, dup: true, zero_sized: false];
type GasCoupon = GasCoupon [storable: true, drop: true, dup: false, zero_sized: false];
type Const<u128, 1000000> = Const<u128, 1000000> [storable: false, drop: false, dup: false, zero_sized: false];
type u128 = u128 [storable: true, drop: true, dup: true, zero_sized: false];
type Uninitialized<u128> = Uninitialized<u128> [storable: false, drop: true, dup: false, zero_sized: false];
type Unit = Struct<ut@Tuple> [storable: true, drop: true, dup: true, zero_sized: true];
type core::bool = Enum<ut@core::bool, Unit, Unit> [storable: true, drop: true, dup: true, zero_sized: false];
type core::internal::LoopResult::<(), core::bool> = Enum<ut@core::internal::LoopResult::<(), core::bool>, Unit, core::bool> [storable: true, drop: true, dup: true, zero_sized: false];
type core::array::Span::<core::starknet::account::Call> = Struct<ut@core::array::Span::<core::starknet::account::Call>, Snapshot<Array<core::starknet::account::Call>>> [storable: true, drop: true, dup: true, zero_sized: false];
type System = System [storable: true, drop: false, dup: false, zero_sized: false];
type GasBuiltin = GasBuiltin [storable: true, drop: false, dup: false, zero_sized: false];

libfunc disable_ap_tracking = disable_ap_tracking;
libfunc store_temp<RangeCheck> = store_temp<RangeCheck>;
libfunc store_temp<GasBuiltin> = store_temp<GasBuiltin>;
libfunc store_temp<System> = store_temp<System>;
libfunc store_temp<core::array::Span::<core::starknet::account::Call>> = store_temp<core::array::Span::<core::starknet::account::Call>>;
libfunc function_call<user@test::foo[67-464]> = function_call<user@test::foo[67-464]>;
libfunc drop<core::array::Span::<core::starknet::account::Call>> = drop<core::array::Span::<core::starknet::account::Call>>;
libfunc enum_match<core::internal::LoopResult::<(), core::bool>> = enum_match<core::internal::LoopResult::<(), core::bool>>;
libfunc branch_align = branch_align;
libfunc drop<Unit> = drop<Unit>;
libfunc redeposit_gas = redeposit_gas;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc enum_init<core::bool, 1> = enum_init<core::bool, 1>;
libfunc store_temp<core::bool> = store_temp<core::bool>;
libfunc alloc_local<u128> = alloc_local<u128>;
libfunc finalize_locals = finalize_locals;
libfunc const_as_immediate<Const<u128, 1000000>> = const_as_immediate<Const<u128, 1000000>>;
libfunc store_local<u128> = store_local<u128>;
libfunc gas_coupon_buy = gas_coupon_buy;
libfunc enable_ap_tracking = enable_ap_tracking;
libfunc jump = jump;
libfunc redeposit_gas_coupon = redeposit_gas_coupon;
libfunc enum_init<core::bool, 0> = enum_init<core::bool, 0>;
libfunc struct_deconstruct<core::array::Span::<core::starknet::account::Call>> = struct_deconstruct<core::array::Span::<core::starknet::account::Call>>;
libfunc array_snapshot_pop_front<core::starknet::account::Call> = array_snapshot_pop_front<core::starknet::account::Call>;
libfunc unbox<core::starknet::account::Call> = unbox<core::starknet::account::Call>;
libfunc struct_construct<core::array::Span::<core::starknet::account::Call>> = struct_construct<core::array::Span::<core::starknet::account::Call>>;
libfunc store_temp<core::starknet::account::Call> = store_temp<core::starknet::account::Call>;
libfunc withdraw_gas = withdraw_gas;
libfunc dup<core::starknet::account::Call> = dup<core::starknet::account::Call>;
libfunc struct_deconstruct<core::starknet::account::Call> = struct_deconstruct<core::starknet::account::Call>;
libfunc drop<felt252> = drop<felt252>;
libfunc drop<core::array::Span::<core::felt252>> = drop<core::array::Span::<core::felt252>>;
libfunc rename<ContractAddress> = rename<ContractAddress>;
libfunc drop<ContractAddress> = drop<ContractAddress>;
libfunc rename<felt252> = rename<felt252>;
libfunc rename<core::array::Span::<core::felt252>> = rename<core::array::Span::<core::felt252>>;
libfunc call_contract_syscall = call_contract_syscall;
libfunc drop<Array<felt252>> = drop<Array<felt252>>;
libfunc drop<core::starknet::account::Call> = drop<core::starknet::account::Call>;
libfunc enum_init<core::internal::LoopResult::<(), core::bool>, 1> = enum_init<core::internal::LoopResult::<(), core::bool>, 1>;
libfunc store_temp<core::internal::LoopResult::<(), core::bool>> = store_temp<core::internal::LoopResult::<(), core::bool>>;
libfunc enum_init<core::internal::LoopResult::<(), core::bool>, 0> = enum_init<core::internal::LoopResult::<(), core::bool>, 0>;

F0:
disable_ap_tracking() -> ();
store_temp<RangeCheck>([0]) -> ([0]);
store_temp<GasBuiltin>([1]) -> ([1]);
store_temp<System>([2]) -> ([2]);
store_temp<core::array::Span::<core::starknet::account::Call>>([3]) -> ([3]);
function_call<user@test::foo[67-464]>([0], [1], [2], [3]) -> ([4], [5], [6], [7], [8]);
drop<core::array::Span::<core::starknet::account::Call>>([7]) -> ();
enum_match<core::internal::LoopResult::<(), core::bool>>([8]) { fallthrough([9]) F0_B0([10]) };
branch_align() -> ();
drop<Unit>([9]) -> ();
redeposit_gas([5]) -> ([11]);
struct_construct<Unit>() -> ([12]);
enum_init<core::bool, 1>([12]) -> ([13]);
store_temp<RangeCheck>([4]) -> ([4]);
store_temp<GasBuiltin>([11]) -> ([11]);
store_temp<System>([6]) -> ([6]);
store_temp<core::bool>([13]) -> ([13]);
return([4], [11], [6], [13]);
F0_B0:
branch_align() -> ();
redeposit_gas([5]) -> ([14]);
store_temp<RangeCheck>([4]) -> ([4]);
store_temp<GasBuiltin>([14]) -> ([14]);
store_temp<System>([6]) -> ([6]);
store_temp<core::bool>([10]) -> ([10]);
return([4], [14], [6], [10]);
F1:
alloc_local<u128>() -> ([5]);
finalize_locals() -> ();
disable_ap_tracking() -> ();
const_as_immediate<Const<u128, 1000000>>() -> ([4]);
store_local<u128>([5], [4]) -> ([4]);
gas_coupon_buy([0], [1], [4]) { fallthrough([6], [7], [8]) F1_B2([9], [10]) };
branch_align() -> ();
store_temp<RangeCheck>([6]) -> ([6]);
store_temp<GasBuiltin>([7]) -> ([7]);
store_temp<System>([2]) -> ([2]);
store_temp<core::array::Span::<core::starknet::account::Call>>([3]) -> ([3]);
function_call<user@test::foo[67-464]>([6], [7], [2], [3]) -> ([11], [12], [13], [14], [15]);
drop<core::array::Span::<core::starknet::account::Call>>([14]) -> ();
enable_ap_tracking() -> ();
enum_match<core::internal::LoopResult::<(), core::bool>>([15]) { fallthrough([16]) F1_B0([17]) };
branch_align() -> ();
drop<Unit>([16]) -> ();
redeposit_gas([12]) -> ([18]);
struct_construct<Unit>() -> ([19]);
enum_init<core::bool, 1>([19]) -> ([20]);
store_temp<GasBuiltin>([18]) -> ([21]);
store_temp<core::bool>([20]) -> ([22]);
jump() { F1_B1() };
F1_B0:
branch_align() -> ();
redeposit_gas([12]) -> ([23]);
store_temp<GasBuiltin>([23]) -> ([21]);
store_temp<core::bool>([17]) -> ([22]);
F1_B1:
disable_ap_tracking() -> ();
redeposit_gas_coupon([21], [8]) -> ([24]);
store_temp<RangeCheck>([11]) -> ([11]);
store_temp<GasBuiltin>([24]) -> ([24]);
store_temp<System>([13]) -> ([13]);
store_temp<core::bool>([22]) -> ([22]);
return([11], [24], [13], [22]);
F1_B2:
branch_align() -> ();
drop<core::array::Span::<core::starknet::account::Call>>([3]) -> ();
redeposit_gas([10]) -> ([25]);
struct_construct<Unit>() -> ([26]);
enum_init<core::bool, 0>([26]) -> ([27]);
store_temp<RangeCheck>([9]) -> ([9]);
store_temp<GasBuiltin>([25]) -> ([25]);
store_temp<System>([2]) -> ([2]);
store_temp<core::bool>([27]) -> ([27]);
return([9], [25], [2], [27]);
F2:
disable_ap_tracking() -> ();
struct_deconstruct<core::array::Span::<core::starknet::account::Call>>([3]) -> ([4]);
array_snapshot_pop_front<core::starknet::account::Call>([4]) { fallthrough([5], [6]) F2_B3([7]) };
branch_align() -> ();
unbox<core::starknet::account::Call>([6]) -> ([8]);
struct_construct<core::array::Span::<core::starknet::account::Call>>([5]) -> ([9]);
enable_ap_tracking() -> ();
store_temp<core::starknet::account::Call>([8]) -> ([8]);
withdraw_gas([0], [1]) { fallthrough([10], [11]) F2_B1([12], [13]) };
branch_align() -> ();
dup<core::starknet::account::Call>([8]) -> ([8], [14]);
struct_deconstruct<core::starknet::account::Call>([14]) -> ([15], [16], [17]);
drop<felt252>([16]) -> ();
drop<core::array::Span::<core::felt252>>([17]) -> ();
rename<ContractAddress>([15]) -> ([18]);
dup<core::starknet::account::Call>([8]) -> ([8], [19]);
struct_deconstruct<core::starknet::account::Call>([19]) -> ([20], [21], [22]);
drop<ContractAddress>([20]) -> ();
drop<core::array::Span::<core::felt252>>([22]) -> ();
rename<felt252>([21]) -> ([23]);
struct_deconstruct<core::starknet::account::Call>([8]) -> ([24], [25], [26]);
drop<ContractAddress>([24]) -> ();
drop<felt252>([25]) -> ();
rename<core::array::Span::<core::felt252>>([26]) -> ([27]);
call_contract_syscall([11], [2], [18], [23], [27]) { fallthrough([28], [29], [30]) F2_B0([31], [32], [33]) };
branch_align() -> ();
disable_ap_tracking() -> ();
drop<core::array::Span::<core::felt252>>([30]) -> ();
store_temp<GasBuiltin>([28]) -> ([28]);
redeposit_gas([28]) -> ([34]);
store_temp<RangeCheck>([10]) -> ([10]);
store_temp<GasBuiltin>([34]) -> ([34]);
store_temp<System>([29]) -> ([29]);
store_temp<core::array::Span::<core::starknet::account::Call>>([9]) -> ([9]);
function_call<user@test::foo[67-464]>([10], [34], [29], [9]) -> ([35], [36], [37], [38], [39]);
return([35], [36], [37], [38], [39]);
F2_B0:
branch_align() -> ();
drop<Array<felt252>>([33]) -> ();
store_temp<GasBuiltin>([31]) -> ([31]);
redeposit_gas([31]) -> ([40]);
store_temp<RangeCheck>([10]) -> ([41]);
store_temp<GasBuiltin>([40]) -> ([42]);
store_temp<System>([32]) -> ([43]);
jump() { F2_B2() };
F2_B1:
branch_align() -> ();
drop<core::starknet::account::Call>([8]) -> ();
redeposit_gas([13]) -> ([44]);
store_temp<RangeCheck>([12]) -> ([41]);
store_temp<GasBuiltin>([44]) -> ([42]);
store_temp<System>([2]) -> ([43]);
F2_B2:
disable_ap_tracking() -> ();
struct_construct<Unit>() -> ([45]);
enum_init<core::bool, 0>([45]) -> ([46]);
enum_init<core::internal::LoopResult::<(), core::bool>, 1>([46]) -> ([47]);
store_temp<core::array::Span::<core::starknet::account::Call>>([9]) -> ([9]);
store_temp<core::internal::LoopResult::<(), core::bool>>([47]) -> ([47]);
return([41], [42], [43], [9], [47]);
F2_B3:
branch_align() -> ();
redeposit_gas([1]) -> ([48]);
struct_construct<Unit>() -> ([49]);
enum_init<core::internal::LoopResult::<(), core::bool>, 0>([49]) -> ([50]);
struct_construct<core::array::Span::<core::starknet::account::Call>>([7]) -> ([51]);
store_temp<RangeCheck>([0]) -> ([0]);
store_temp<GasBuiltin>([48]) -> ([48]);
store_temp<System>([2]) -> ([2]);
store_temp<core::array::Span::<core::starknet::account::Call>>([51]) -> ([51]);
store_temp<core::internal::LoopResult::<(), core::bool>>([50]) -> ([50]);
return([0], [48], [2], [51], [50]);

test::foo@F0([0]: RangeCheck, [1]: GasBuiltin, [2]: System, [3]: core::array::Span::<core::starknet::account::Call>) -> (RangeCheck, GasBuiltin, System, core::bool);
test::bar@F1([0]: RangeCheck, [1]: GasBuiltin, [2]: System, [3]: core::array::Span::<core::starknet::account::Call>) -> (RangeCheck, GasBuiltin, System, core::bool);
test::foo[67-464]@F2([0]: RangeCheck, [1]: GasBuiltin, [2]: System, [3]: core::array::Span::<core::starknet::account::Call>) -> (RangeCheck, GasBuiltin, System, core::array::Span::<core::starknet::account::Call>, core::internal::LoopResult::<(), core::bool>);
